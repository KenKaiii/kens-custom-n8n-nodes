{
	"scenarios": [
		{
			"name": "Customer Data Validation & Enrichment",
			"description": "Validate customer data, standardize formats, and enrich with additional information",
			"business_use": "CRM systems, lead processing, data quality",
			"set_node_data": {
				"customers": [
					{
						"id": "CUST001",
						"name": "john doe",
						"email": "JOHN.DOE@GMAIL.COM",
						"phone": "+1-555-123-4567",
						"company": "acme corp",
						"website": "www.acme-corp.com",
						"created_at": "2024-01-15T10:30:00Z",
						"revenue": "50000",
						"country": "US"
					},
					{
						"id": "CUST002",
						"name": "jane smith",
						"email": "jane.smith@techstart.io",
						"phone": "44-20-7946-0958",
						"company": "TechStart Ltd",
						"website": "https://techstart.io",
						"created_at": "2024-02-01T14:22:00Z",
						"revenue": "125000",
						"country": "GB"
					}
				]
			},
			"supercode_script": `// Customer Data Validation & Enrichment
const customers = $input.json.customers;
const processedCustomers = customers.map(customer => {
    // Name formatting
    const formattedName = _.startCase(_.toLower(customer.name));
    
    // Email validation and standardization
    const email = _.toLower(customer.email);
    const isValidEmail = validator.isEmail(email);
    
    // Phone number parsing and formatting
    let formattedPhone = null;
    let phoneCountry = null;
    try {
        const parsed = phoneNumber.parsePhoneNumber(customer.phone);
        formattedPhone = parsed.formatInternational();
        phoneCountry = parsed.country;
    } catch (e) {
        formattedPhone = customer.phone; // Keep original if parsing fails
    }
    
    // Website URL standardization
    let formattedWebsite = customer.website;
    if (formattedWebsite && !formattedWebsite.startsWith('http')) {
        formattedWebsite = 'https://' + formattedWebsite.replace(/^www\\./, '');
    }
    
    // Date standardization
    const createdDate = dayjs(customer.created_at);
    const daysSinceCreated = dayjs().diff(createdDate, 'day');
    
    // Revenue classification
    const revenue = parseFloat(customer.revenue);
    let customerTier = 'Bronze';
    if (revenue >= 100000) customerTier = 'Gold';
    else if (revenue >= 50000) customerTier = 'Silver';
    
    // Generate customer hash for deduplication
    const customerHash = CryptoJS.MD5(email + formattedName).toString();
    
    return {
        id: customer.id,
        name: formattedName,
        email: email,
        email_valid: isValidEmail,
        phone: formattedPhone,
        phone_country: phoneCountry,
        company: _.startCase(_.toLower(customer.company)),
        website: formattedWebsite,
        created_at: createdDate.format('YYYY-MM-DD HH:mm:ss'),
        days_since_created: daysSinceCreated,
        revenue: revenue,
        customer_tier: customerTier,
        country: customer.country,
        customer_hash: customerHash,
        processed_at: dayjs().toISOString()
    };
});

return {
    processed_customers: processedCustomers,
    total_count: processedCustomers.length,
    valid_emails: processedCustomers.filter(c => c.email_valid).length,
    tier_distribution: _.countBy(processedCustomers, 'customer_tier')
};`,
			"libraries_used": ["lodash", "validator", "phoneNumber", "dayjs", "CryptoJS"],
			"expected_output": "Standardized customer data with validation, enrichment, and business intelligence"
		},

		{
			"name": "API Response Processing & Error Handling",
			"description": "Process multiple API responses, handle errors, and aggregate data",
			"business_use": "API integrations, data aggregation, error monitoring",
			"set_node_data": {
				"api_responses": [
					{
						"service": "payment_gateway",
						"status": 200,
						"data": {
							"transactions": [
								{ "id": "txn_001", "amount": 99.99, "currency": "USD", "status": "completed" },
								{ "id": "txn_002", "amount": 149.5, "currency": "EUR", "status": "pending" }
							]
						},
						"response_time": 245,
						"timestamp": "2024-01-15T10:30:00Z"
					},
					{
						"service": "inventory_api",
						"status": 500,
						"error": "Internal Server Error",
						"data": null,
						"response_time": 5000,
						"timestamp": "2024-01-15T10:31:00Z"
					},
					{
						"service": "user_service",
						"status": 200,
						"data": {
							"users": [
								{ "id": 123, "name": "John Doe", "last_login": "2024-01-14T15:30:00Z" },
								{ "id": 124, "name": "Jane Smith", "last_login": "2024-01-15T09:15:00Z" }
							]
						},
						"response_time": 120,
						"timestamp": "2024-01-15T10:32:00Z"
					}
				]
			},
			"supercode_script": `// API Response Processing & Error Handling
const responses = $input.json.api_responses;

const processedData = {
    successful_responses: [],
    failed_responses: [],
    aggregated_data: {},
    performance_metrics: {},
    alerts: []
};

responses.forEach(response => {
    const processedResponse = {
        service: response.service,
        status: response.status,
        response_time: response.response_time,
        timestamp: dayjs(response.timestamp).format('YYYY-MM-DD HH:mm:ss'),
        success: response.status >= 200 && response.status < 300
    };
    
    if (processedResponse.success) {
        processedData.successful_responses.push({
            ...processedResponse,
            data_summary: response.data ? {
                keys: Object.keys(response.data),
                record_count: _.sumBy(Object.values(response.data), arr => 
                    Array.isArray(arr) ? arr.length : 0
                )
            } : null
        });
        
        // Aggregate specific data types
        if (response.service === 'payment_gateway' && response.data?.transactions) {
            processedData.aggregated_data.payments = {
                total_transactions: response.data.transactions.length,
                total_amount: _.sumBy(response.data.transactions, 'amount'),
                completed_transactions: response.data.transactions.filter(t => t.status === 'completed').length,
                currencies: _.uniq(response.data.transactions.map(t => t.currency))
            };
        }
        
        if (response.service === 'user_service' && response.data?.users) {
            processedData.aggregated_data.users = {
                total_users: response.data.users.length,
                recent_logins: response.data.users.filter(u => 
                    dayjs().diff(dayjs(u.last_login), 'hours') < 24
                ).length
            };
        }
    } else {
        processedData.failed_responses.push({
            ...processedResponse,
            error: response.error || 'Unknown error'
        });
        
        // Generate alerts for failures
        processedData.alerts.push({
            type: 'service_failure',
            service: response.service,
            message: \`Service \${response.service} failed with status \${response.status}\`,
            error: response.error,
            timestamp: processedResponse.timestamp,
            severity: response.status >= 500 ? 'high' : 'medium'
        });
    }
});

// Performance analysis
processedData.performance_metrics = {
    average_response_time: _.meanBy(responses, 'response_time'),
    slowest_service: _.maxBy(responses, 'response_time')?.service,
    fastest_service: _.minBy(responses, 'response_time')?.service,
    success_rate: (processedData.successful_responses.length / responses.length * 100).toFixed(2) + '%'
};

// Add performance alerts
const slowResponses = responses.filter(r => r.response_time > 1000);
slowResponses.forEach(response => {
    processedData.alerts.push({
        type: 'performance',
        service: response.service,
        message: \`Slow response time: \${response.response_time}ms\`,
        timestamp: dayjs(response.timestamp).format('YYYY-MM-DD HH:mm:ss'),
        severity: 'medium'
    });
});

return {
    summary: {
        total_services: responses.length,
        successful: processedData.successful_responses.length,
        failed: processedData.failed_responses.length,
        alerts_generated: processedData.alerts.length
    },
    ...processedData,
    processed_at: dayjs().toISOString()
};`,
			"libraries_used": ["lodash", "dayjs"],
			"expected_output": "Processed API responses with error handling, performance metrics, and automated alerts"
		},

		{
			"name": "Excel Report Generation & Data Analysis",
			"description": "Process raw data and generate structured reports with calculations",
			"business_use": "Business reporting, data analysis, automated reports",
			"set_node_data": {
				"sales_data": [
					{
						"sale_id": "SALE_001",
						"date": "2024-01-15",
						"customer_id": "CUST_123",
						"product": "Premium Widget",
						"category": "Electronics",
						"quantity": 2,
						"unit_price": 299.99,
						"discount_percent": 10,
						"sales_rep": "John Smith",
						"region": "North America"
					},
					{
						"sale_id": "SALE_002",
						"date": "2024-01-16",
						"customer_id": "CUST_124",
						"product": "Standard Widget",
						"category": "Electronics",
						"quantity": 5,
						"unit_price": 149.99,
						"discount_percent": 5,
						"sales_rep": "Jane Doe",
						"region": "Europe"
					},
					{
						"sale_id": "SALE_003",
						"date": "2024-01-17",
						"customer_id": "CUST_125",
						"product": "Widget Pro",
						"category": "Electronics",
						"quantity": 1,
						"unit_price": 499.99,
						"discount_percent": 0,
						"sales_rep": "John Smith",
						"region": "Asia Pacific"
					}
				]
			},
			"supercode_script": `// Excel Report Generation & Data Analysis
const salesData = $input.json.sales_data;

// Calculate derived fields for each sale
const processedSales = salesData.map(sale => {
    const subtotal = sale.quantity * sale.unit_price;
    const discountAmount = subtotal * (sale.discount_percent / 100);
    const total = subtotal - discountAmount;
    
    return {
        ...sale,
        subtotal: parseFloat(subtotal.toFixed(2)),
        discount_amount: parseFloat(discountAmount.toFixed(2)),
        total: parseFloat(total.toFixed(2)),
        sale_date: dayjs(sale.date).format('YYYY-MM-DD'),
        month: dayjs(sale.date).format('YYYY-MM'),
        quarter: \`Q\${dayjs(sale.date).quarter()} \${dayjs(sale.date).year()}\`
    };
});

// Generate summary analytics
const analytics = {
    overview: {
        total_sales: processedSales.length,
        total_revenue: _.sumBy(processedSales, 'total'),
        total_discount_given: _.sumBy(processedSales, 'discount_amount'),
        average_order_value: _.meanBy(processedSales, 'total'),
        total_units_sold: _.sumBy(processedSales, 'quantity')
    },
    
    by_region: _.mapValues(_.groupBy(processedSales, 'region'), group => ({
        sales_count: group.length,
        revenue: _.sumBy(group, 'total'),
        avg_order_value: _.meanBy(group, 'total'),
        units_sold: _.sumBy(group, 'quantity')
    })),
    
    by_sales_rep: _.mapValues(_.groupBy(processedSales, 'sales_rep'), group => ({
        sales_count: group.length,
        revenue: _.sumBy(group, 'total'),
        commission: _.sumBy(group, 'total') * 0.05, // 5% commission
        avg_deal_size: _.meanBy(group, 'total')
    })),
    
    by_product: _.mapValues(_.groupBy(processedSales, 'product'), group => ({
        units_sold: _.sumBy(group, 'quantity'),
        revenue: _.sumBy(group, 'total'),
        avg_selling_price: _.meanBy(group, 'unit_price')
    })),
    
    by_month: _.mapValues(_.groupBy(processedSales, 'month'), group => ({
        sales_count: group.length,
        revenue: _.sumBy(group, 'total'),
        growth_rate: null // Would calculate with previous period data
    }))
};

// Generate Excel-ready worksheets
const excelData = {
    summary_sheet: {
        title: "Sales Summary Report",
        generated_at: dayjs().format('YYYY-MM-DD HH:mm:ss'),
        period: \`\${dayjs(_.minBy(processedSales, 'sale_date').sale_date).format('MMM DD')} - \${dayjs(_.maxBy(processedSales, 'sale_date').sale_date).format('MMM DD, YYYY')}\`,
        ...analytics.overview
    },
    
    detailed_sales: processedSales.map(sale => ({
        'Sale ID': sale.sale_id,
        'Date': sale.sale_date,
        'Customer': sale.customer_id,
        'Product': sale.product,
        'Category': sale.category,
        'Quantity': sale.quantity,
        'Unit Price': \`$\${sale.unit_price}\`,
        'Subtotal': \`$\${sale.subtotal}\`,
        'Discount %': \`\${sale.discount_percent}%\`,
        'Discount Amount': \`$\${sale.discount_amount}\`,
        'Total': \`$\${sale.total}\`,
        'Sales Rep': sale.sales_rep,
        'Region': sale.region,
        'Quarter': sale.quarter
    })),
    
    regional_summary: Object.entries(analytics.by_region).map(([region, data]) => ({
        'Region': region,
        'Sales Count': data.sales_count,
        'Revenue': \`$\${data.revenue.toFixed(2)}\`,
        'Avg Order Value': \`$\${data.avg_order_value.toFixed(2)}\`,
        'Units Sold': data.units_sold,
        'Market Share': \`\${((data.revenue / analytics.overview.total_revenue) * 100).toFixed(1)}%\`
    })),
    
    sales_rep_performance: Object.entries(analytics.by_sales_rep).map(([rep, data]) => ({
        'Sales Rep': rep,
        'Sales Count': data.sales_count,
        'Revenue': \`$\${data.revenue.toFixed(2)}\`,
        'Commission': \`$\${data.commission.toFixed(2)}\`,
        'Avg Deal Size': \`$\${data.avg_deal_size.toFixed(2)}\`,
        'Performance Score': Math.round((data.revenue / analytics.overview.total_revenue) * 100)
    }))
};

// Format currency values properly
const formatCurrency = (amount) => \`$\${parseFloat(amount).toLocaleString('en-US', {minimumFractionDigits: 2})}\`;

return {
    report_metadata: {
        generated_at: dayjs().toISOString(),
        period_start: _.minBy(processedSales, 'sale_date').sale_date,
        period_end: _.maxBy(processedSales, 'sale_date').sale_date,
        total_records: processedSales.length
    },
    analytics: analytics,
    excel_worksheets: excelData,
    key_insights: [
        \`Top performing region: \${_.maxBy(Object.entries(analytics.by_region), ([k,v]) => v.revenue)[0]}\`,
        \`Best sales rep: \${_.maxBy(Object.entries(analytics.by_sales_rep), ([k,v]) => v.revenue)[0]}\`,
        \`Average discount rate: \${((analytics.overview.total_discount_given / (analytics.overview.total_revenue + analytics.overview.total_discount_given)) * 100).toFixed(1)}%\`,
        \`Top selling product: \${_.maxBy(Object.entries(analytics.by_product), ([k,v]) => v.units_sold)[0]}\`
    ]
};`,
			"libraries_used": ["lodash", "dayjs"],
			"expected_output": "Comprehensive sales report with analytics, Excel-ready data, and business insights"
		},

		{
			"name": "E-commerce Order Processing & Inventory Management",
			"description": "Process orders, validate inventory, calculate shipping, and update stock levels",
			"business_use": "E-commerce platforms, order fulfillment, inventory management",
			"set_node_data": {
				"orders": [
					{
						"order_id": "ORD_001",
						"customer": {
							"id": "CUST_123",
							"email": "john@example.com",
							"shipping_address": {
								"street": "123 Main St",
								"city": "New York",
								"state": "NY",
								"zip": "10001",
								"country": "US"
							}
						},
						"items": [
							{ "sku": "WIDGET_001", "name": "Premium Widget", "quantity": 2, "price": 99.99 },
							{ "sku": "WIDGET_002", "name": "Standard Widget", "quantity": 1, "price": 49.99 }
						],
						"order_date": "2024-01-15T14:30:00Z",
						"currency": "USD"
					},
					{
						"order_id": "ORD_002",
						"customer": {
							"id": "CUST_124",
							"email": "jane@example.com",
							"shipping_address": {
								"street": "456 Oak Ave",
								"city": "Los Angeles",
								"state": "CA",
								"zip": "90210",
								"country": "US"
							}
						},
						"items": [
							{ "sku": "WIDGET_003", "name": "Deluxe Widget", "quantity": 3, "price": 149.99 }
						],
						"order_date": "2024-01-15T15:45:00Z",
						"currency": "USD"
					}
				],
				"inventory": [
					{ "sku": "WIDGET_001", "stock_level": 50, "reserved": 5, "cost": 60.0, "weight_kg": 0.5 },
					{
						"sku": "WIDGET_002",
						"stock_level": 100,
						"reserved": 10,
						"cost": 30.0,
						"weight_kg": 0.3
					},
					{ "sku": "WIDGET_003", "stock_level": 8, "reserved": 2, "cost": 90.0, "weight_kg": 0.8 }
				],
				"shipping_zones": [
					{ "state": "NY", "zone": "East", "base_rate": 5.99, "per_kg": 2.5 },
					{ "state": "CA", "zone": "West", "base_rate": 7.99, "per_kg": 3.0 }
				]
			},
			"supercode_script": `// E-commerce Order Processing & Inventory Management
const { orders, inventory, shipping_zones } = $input.json;

// Create inventory lookup for quick access
const inventoryMap = _.keyBy(inventory, 'sku');
const shippingZoneMap = _.keyBy(shipping_zones, 'state');

const processedOrders = orders.map(order => {
    let orderValid = true;
    let validationErrors = [];
    let totalWeight = 0;
    let subtotal = 0;
    let totalCost = 0;
    
    // Validate email
    const emailValid = validator.isEmail(order.customer.email);
    if (!emailValid) {
        validationErrors.push('Invalid email address');
        orderValid = false;
    }
    
    // Process each item
    const processedItems = order.items.map(item => {
        const inventoryItem = inventoryMap[item.sku];
        let itemValid = true;
        let itemErrors = [];
        
        if (!inventoryItem) {
            itemErrors.push('SKU not found in inventory');
            itemValid = false;
        } else {
            const availableStock = inventoryItem.stock_level - inventoryItem.reserved;
            if (item.quantity > availableStock) {
                itemErrors.push(\`Insufficient stock: requested \${item.quantity}, available \${availableStock}\`);
                itemValid = false;
            } else {
                // Calculate item totals
                const itemSubtotal = item.quantity * item.price;
                const itemCost = item.quantity * inventoryItem.cost;
                const itemWeight = item.quantity * inventoryItem.weight_kg;
                
                subtotal += itemSubtotal;
                totalCost += itemCost;
                totalWeight += itemWeight;
            }
        }
        
        if (!itemValid) {
            orderValid = false;
            validationErrors.push(...itemErrors);
        }
        
        return {
            ...item,
            valid: itemValid,
            errors: itemErrors,
            available_stock: inventoryItem ? inventoryItem.stock_level - inventoryItem.reserved : 0,
            unit_cost: inventoryItem ? inventoryItem.cost : 0,
            unit_weight_kg: inventoryItem ? inventoryItem.weight_kg : 0,
            line_total: item.quantity * item.price,
            line_cost: inventoryItem ? item.quantity * inventoryItem.cost : 0,
            line_weight: inventoryItem ? item.quantity * inventoryItem.weight_kg : 0
        };
    });
    
    // Calculate shipping
    let shippingCost = 0;
    const shippingZone = shippingZoneMap[order.customer.shipping_address.state];
    if (shippingZone && orderValid) {
        shippingCost = shippingZone.base_rate + (totalWeight * shippingZone.per_kg);
    } else if (!shippingZone) {
        validationErrors.push('Shipping zone not found for state');
        orderValid = false;
    }
    
    // Calculate taxes (example: 8.5% for simplicity)
    const taxRate = 0.085;
    const taxAmount = orderValid ? (subtotal + shippingCost) * taxRate : 0;
    
    // Final totals
    const orderTotal = subtotal + shippingCost + taxAmount;
    const grossMargin = subtotal - totalCost;
    const marginPercent = subtotal > 0 ? (grossMargin / subtotal) * 100 : 0;
    
    // Generate order hash for tracking
    const orderHash = CryptoJS.MD5(order.order_id + order.customer.email + subtotal.toString()).toString();
    
    return {
        order_id: order.order_id,
        customer_id: order.customer.id,
        customer_email: order.customer.email,
        email_valid: emailValid,
        shipping_address: order.customer.shipping_address,
        shipping_zone: shippingZone ? shippingZone.zone : null,
        items: processedItems,
        order_date: dayjs(order.order_date).format('YYYY-MM-DD HH:mm:ss'),
        currency: order.currency,
        
        // Financial calculations
        subtotal: parseFloat(subtotal.toFixed(2)),
        shipping_cost: parseFloat(shippingCost.toFixed(2)),
        tax_amount: parseFloat(taxAmount.toFixed(2)),
        order_total: parseFloat(orderTotal.toFixed(2)),
        total_cost: parseFloat(totalCost.toFixed(2)),
        gross_margin: parseFloat(grossMargin.toFixed(2)),
        margin_percent: parseFloat(marginPercent.toFixed(2)),
        
        // Physical properties
        total_weight_kg: parseFloat(totalWeight.toFixed(2)),
        item_count: order.items.reduce((sum, item) => sum + item.quantity, 0),
        
        // Validation
        valid: orderValid,
        validation_errors: validationErrors,
        order_hash: orderHash,
        
        // Status
        status: orderValid ? 'ready_to_process' : 'validation_failed',
        processing_priority: orderTotal > 500 ? 'high' : orderTotal > 200 ? 'medium' : 'low'
    };
});

// Generate inventory updates for valid orders
const inventoryUpdates = {};
processedOrders.forEach(order => {
    if (order.valid) {
        order.items.forEach(item => {
            if (!inventoryUpdates[item.sku]) {
                inventoryUpdates[item.sku] = {
                    sku: item.sku,
                    current_stock: inventoryMap[item.sku].stock_level,
                    current_reserved: inventoryMap[item.sku].reserved,
                    new_reserved: inventoryMap[item.sku].reserved,
                    orders_to_fulfill: []
                };
            }
            inventoryUpdates[item.sku].new_reserved += item.quantity;
            inventoryUpdates[item.sku].orders_to_fulfill.push({
                order_id: order.order_id,
                quantity: item.quantity
            });
        });
    }
});

// Summary analytics
const summary = {
    total_orders: processedOrders.length,
    valid_orders: processedOrders.filter(o => o.valid).length,
    failed_orders: processedOrders.filter(o => !o.valid).length,
    total_revenue: _.sumBy(processedOrders.filter(o => o.valid), 'order_total'),
    total_margin: _.sumBy(processedOrders.filter(o => o.valid), 'gross_margin'),
    average_order_value: _.meanBy(processedOrders.filter(o => o.valid), 'order_total') || 0,
    total_items: _.sumBy(processedOrders.filter(o => o.valid), 'item_count'),
    high_priority_orders: processedOrders.filter(o => o.processing_priority === 'high').length
};

return {
    processed_orders: processedOrders,
    inventory_updates: Object.values(inventoryUpdates),
    summary: summary,
    validation_report: {
        invalid_emails: processedOrders.filter(o => !o.email_valid).length,
        stock_issues: processedOrders.filter(o => 
            o.validation_errors.some(e => e.includes('stock'))
        ).length,
        shipping_issues: processedOrders.filter(o => 
            o.validation_errors.some(e => e.includes('shipping'))
        ).length
    },
    processed_at: dayjs().toISOString()
};`,
			"libraries_used": ["lodash", "validator", "dayjs", "CryptoJS"],
			"expected_output": "Fully processed orders with inventory validation, shipping calculations, and financial analytics"
		},

		{
			"name": "Financial Data Analysis & Risk Assessment",
			"description": "Analyze financial transactions, detect anomalies, and calculate risk metrics",
			"business_use": "Financial services, fraud detection, compliance monitoring",
			"set_node_data": {
				"transactions": [
					{
						"transaction_id": "TXN_001",
						"account_id": "ACC_12345",
						"amount": 2500.0,
						"currency": "USD",
						"transaction_type": "transfer",
						"timestamp": "2024-01-15T09:30:00Z",
						"merchant": "Tech Solutions Inc",
						"category": "business_services",
						"location": { "country": "US", "city": "New York" },
						"payment_method": "bank_transfer"
					},
					{
						"transaction_id": "TXN_002",
						"account_id": "ACC_12345",
						"amount": 45.99,
						"currency": "USD",
						"transaction_type": "purchase",
						"timestamp": "2024-01-15T14:22:00Z",
						"merchant": "Coffee Shop",
						"category": "food_beverage",
						"location": { "country": "US", "city": "New York" },
						"payment_method": "credit_card"
					},
					{
						"transaction_id": "TXN_003",
						"account_id": "ACC_12345",
						"amount": 15000.0,
						"currency": "USD",
						"transaction_type": "transfer",
						"timestamp": "2024-01-15T23:45:00Z",
						"merchant": "Offshore Holdings Ltd",
						"category": "investment",
						"location": { "country": "BZ", "city": "Belize City" },
						"payment_method": "wire_transfer"
					},
					{
						"transaction_id": "TXN_004",
						"account_id": "ACC_67890",
						"amount": 890.5,
						"currency": "EUR",
						"transaction_type": "purchase",
						"timestamp": "2024-01-16T10:15:00Z",
						"merchant": "Electronics Store",
						"category": "electronics",
						"location": { "country": "DE", "city": "Berlin" },
						"payment_method": "debit_card"
					}
				],
				"account_profiles": [
					{
						"account_id": "ACC_12345",
						"account_type": "business",
						"risk_score": 3.2,
						"monthly_limit": 50000,
						"avg_transaction_amount": 1200,
						"account_age_days": 365,
						"kyc_status": "verified"
					},
					{
						"account_id": "ACC_67890",
						"account_type": "personal",
						"risk_score": 1.8,
						"monthly_limit": 10000,
						"avg_transaction_amount": 350,
						"account_age_days": 180,
						"kyc_status": "verified"
					}
				]
			},
			"supercode_script": `// Financial Data Analysis & Risk Assessment
const { transactions, account_profiles } = $input.json;

// Create account lookup
const accountMap = _.keyBy(account_profiles, 'account_id');

// High-risk countries for compliance
const highRiskCountries = ['BZ', 'PK', 'IR', 'KP']; 
const highRiskCategories = ['gambling', 'cryptocurrency', 'money_transfer'];

const analyzedTransactions = transactions.map(txn => {
    const account = accountMap[txn.account_id];
    const txnDate = dayjs(txn.timestamp);
    
    // Risk factor calculations
    let riskFactors = [];
    let riskScore = account ? account.risk_score : 5.0;
    
    // Amount-based risk
    const avgAmount = account ? account.avg_transaction_amount : 1000;
    const amountDeviation = Math.abs(txn.amount - avgAmount) / avgAmount;
    if (amountDeviation > 5) { // 5x average
        riskFactors.push('large_amount_deviation');
        riskScore += 2.0;
    }
    
    // Time-based risk (late night transactions)
    const hour = txnDate.hour();
    if (hour >= 23 || hour <= 5) {
        riskFactors.push('unusual_time');
        riskScore += 0.5;
    }
    
    // Location-based risk
    if (highRiskCountries.includes(txn.location.country)) {
        riskFactors.push('high_risk_country');
        riskScore += 3.0;
    }
    
    // Category-based risk
    if (highRiskCategories.includes(txn.category)) {
        riskFactors.push('high_risk_category');
        riskScore += 1.5;
    }
    
    // Large transfer risk
    if (txn.transaction_type === 'transfer' && txn.amount > 10000) {
        riskFactors.push('large_transfer');
        riskScore += 1.0;
    }
    
    // Currency conversion for USD comparison
    let usdAmount = txn.amount;
    if (txn.currency === 'EUR') {
        usdAmount = txn.amount * 1.08; // Simplified conversion rate
    }
    
    // Determine risk level
    let riskLevel = 'low';
    if (riskScore >= 7) riskLevel = 'high';
    else if (riskScore >= 4) riskLevel = 'medium';
    
    // Generate transaction hash for tracking
    const txnHash = CryptoJS.SHA256(
        txn.transaction_id + txn.account_id + txn.amount.toString() + txn.timestamp
    ).toString();
    
    return {
        ...txn,
        transaction_date: txnDate.format('YYYY-MM-DD'),
        transaction_time: txnDate.format('HH:mm:ss'),
        day_of_week: txnDate.format('dddd'),
        usd_amount: parseFloat(usdAmount.toFixed(2)),
        account_type: account ? account.account_type : 'unknown',
        kyc_status: account ? account.kyc_status : 'unknown',
        
        // Risk assessment
        risk_score: parseFloat(riskScore.toFixed(2)),
        risk_level: riskLevel,
        risk_factors: riskFactors,
        requires_review: riskLevel === 'high' || riskFactors.length >= 2,
        
        // Analytics
        amount_vs_avg_ratio: account ? parseFloat((txn.amount / account.avg_transaction_amount).toFixed(2)) : null,
        transaction_hash: txnHash,
        
        // Compliance flags
        suspicious_activity: riskLevel === 'high' && riskFactors.includes('high_risk_country'),
        large_cash_equivalent: txn.amount >= 10000,
        cross_border: txn.location.country !== 'US'
    };
});

// Generate analytics and alerts
const analytics = {
    transaction_summary: {
        total_transactions: analyzedTransactions.length,
        total_usd_volume: _.sumBy(analyzedTransactions, 'usd_amount'),
        avg_transaction_size: _.meanBy(analyzedTransactions, 'usd_amount'),
        high_risk_count: analyzedTransactions.filter(t => t.risk_level === 'high').length,
        requires_review_count: analyzedTransactions.filter(t => t.requires_review).length
    },
    
    risk_distribution: _.countBy(analyzedTransactions, 'risk_level'),
    
    by_account: _.mapValues(_.groupBy(analyzedTransactions, 'account_id'), group => ({
        transaction_count: group.length,
        total_volume: _.sumBy(group, 'usd_amount'),
        avg_risk_score: _.meanBy(group, 'risk_score'),
        high_risk_transactions: group.filter(t => t.risk_level === 'high').length,
        suspicious_patterns: group.filter(t => t.suspicious_activity).length
    })),
    
    by_country: _.mapValues(_.groupBy(analyzedTransactions, 'location.country'), group => ({
        transaction_count: group.length,
        total_volume: _.sumBy(group, 'usd_amount'),
        avg_risk_score: _.meanBy(group, 'risk_score')
    })),
    
    time_analysis: {
        by_hour: _.countBy(analyzedTransactions, txn => dayjs(txn.timestamp).hour()),
        unusual_time_count: analyzedTransactions.filter(t => 
            t.risk_factors.includes('unusual_time')
        ).length
    }
};

// Generate compliance alerts
const alerts = [];

// High-risk transaction alerts
analyzedTransactions.forEach(txn => {
    if (txn.risk_level === 'high') {
        alerts.push({
            type: 'high_risk_transaction',
            transaction_id: txn.transaction_id,
            account_id: txn.account_id,
            risk_score: txn.risk_score,
            risk_factors: txn.risk_factors,
            amount: txn.amount,
            currency: txn.currency,
            severity: 'high',
            requires_immediate_review: true
        });
    }
    
    if (txn.large_cash_equivalent) {
        alerts.push({
            type: 'large_transaction_reporting',
            transaction_id: txn.transaction_id,
            account_id: txn.account_id,
            amount: txn.usd_amount,
            description: 'Transaction exceeds $10,000 USD equivalent - CTR filing required',
            severity: 'medium',
            compliance_action: 'file_ctr'
        });
    }
});

// Account-level alerts
Object.entries(analytics.by_account).forEach(([accountId, data]) => {
    if (data.high_risk_transactions > 1) {
        alerts.push({
            type: 'pattern_detection',
            account_id: accountId,
            description: \`Account has \${data.high_risk_transactions} high-risk transactions\`,
            severity: 'medium',
            requires_investigation: true
        });
    }
});

return {
    analyzed_transactions: analyzedTransactions,
    analytics: analytics,
    compliance_alerts: alerts,
    summary: {
        total_volume_usd: analytics.transaction_summary.total_usd_volume,
        risk_summary: \`\${analytics.risk_distribution.high || 0} high, \${analytics.risk_distribution.medium || 0} medium, \${analytics.risk_distribution.low || 0} low risk\`,
        alerts_generated: alerts.length,
        accounts_monitored: Object.keys(analytics.by_account).length,
        countries_involved: Object.keys(analytics.by_country).length
    },
    processed_at: dayjs().toISOString()
};`,
			"libraries_used": ["lodash", "dayjs", "CryptoJS"],
			"expected_output": "Comprehensive financial analysis with risk scoring, compliance alerts, and fraud detection"
		}
	]
}
